[
["index.html", "An Introduction to R Chapter 1 Prerequisites", " An Introduction to R James Rigby 2019-05-17 Chapter 1 Prerequisites This chapter assumes that you are familiar with the basics of the R language. While we will review logic some logical operators, we will not discuss basic arithmatic operators, common functions (i.e., mean), or data structures. Please review the material on base R if you are still uncomfortable with the foundations of the language. If you have yet to do so please install and load tidyverse by running the following code install.packages(&quot;tidyverse&quot;) "],
["supplemental-resources.html", "1.1 Supplemental Resources", " 1.1 Supplemental Resources Dplyr Vignette R For Data Scientists: Chapter 5 "],
["material-overview.html", "Chapter 2 Material Overview", " Chapter 2 Material Overview Part 1: What is dplyr? (15 Minutes) Part 2: dplyr’s Core Functions (45 Minutes) Break (15 Minutes) Activity 1 (30 Minutes) Part 3: Join Functions (30 Minutes) Break (15 Minutes) Activity 2 (30 Minutes) "],
["what-is-dplyr.html", "Chapter 3 What is dplyr?", " Chapter 3 What is dplyr? dplyr is a package that tries to provide a set of functions that utilizes a consistent design, philosophy, grammar, and data structure This consistency increases usability and interpretability of code It is consistently updated and supported by members of the R-Core team and creaters of RStudio It is the most commonly used to manipulate data within the R program "],
["why-is-data-manipulation-important.html", "3.1 Why is Data Manipulation Important?", " 3.1 Why is Data Manipulation Important? 3.1.1 Example 1: Survey Data Table 3.1: Example of Survey Data ResponseId Status last_name Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_3oR2O5GVj417Rb8 8 NA NA 1 2 1 1 1 R_24kfInksYNZC2Bb 0 NA 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 0 NA 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 0 NA 5 1 1 3 1 1 R_3n9rQagKRteaa0F 0 NA 3 1 2 4 5 5 R_beYF2qSztK7r6jn 0 NA 5 1 4 5 4 3 3.1.2 What’s Wrong With the Survey Data? Some of the meta-data collected by the survey platform is not meaningful. It is unclear what the data (i.e., Q1.1) is referring to. Items that start with Q1 and Q2 are associated with unique scales that need to be formed into composites. Some observations were created by you during pilot testing and should not be included. "],
["this-isnt-relevant-to-me-my-research-is-experimental.html", "3.2 This Isn’t Relevant to Me - My Research is Experimental!", " 3.2 This Isn’t Relevant to Me - My Research is Experimental! 3.2.1 Example 2: Experimental Data Table 3.2: Example of Experimental Data id condition pre non_naieve 1 0 4.78 0 2 0 6.68 0 3 0 6.08 0 4 1 3.69 0 5 1 3.63 1 6 1 5.28 1 id condition post non_naieve 1 0 7.78 0 2 0 5.47 0 3 0 7.06 0 4 1 6.44 0 5 1 5.80 1 6 1 6.21 1 3.2.2 What’s Wrong With the Experimental Data? Some of your participants figured out the purpose of your expiriment making their responses invalid. Your pre and post scale was miscalibrated and is .3 higher than it should be. Your pre and post measures are stored in seperate data files. "],
["take-aways.html", "3.3 Take-Aways", " 3.3 Take-Aways No matter what paradigm you work in data management is critical. Tidy data rarely exists in the wild. Efficiently managing data will save you time and make you a valuable assest to your collaborators. "],
["dplyr-functions.html", "Chapter 4 dplyr Functions", " Chapter 4 dplyr Functions Core dplyr Functions for Data Manipulation filter(): select rows based on some logical condition select(): select columns based on their names rename(): rename columns mutate(): add new variables that are functions of old - variables group_by(): perform grouped operations summarise(): Create summary statistics for a group arrange(): reorder rows based on some column Non-Exhaustive List of Helper Functions desc(): arranges in decending order starts_with(“abc”): matches names that being “abc” (i.e., abc1) ends_with(“abc”): matches names that end “abc” (i.e., cat_abc) contains(“abc”): matches names that contain “abc” (i.e., new_abc1) num_range(“x”, 1:3) matches x1, x2, x3 count(): Counts the number of rows in a dataset/group group_indices(): creates vector of integer ids for group rowwise(): groups the data by columns and applies functions across columns "],
["form.html", "4.1 dplyr Function Structure", " 4.1 dplyr Function Structure All of the core dplyr functions take the following form: function(data, transformation, …) function: the dplyr function that you want to use data: the data frame or tibble you want to use the function on transformation: the transformation that you want to perform …: other transformations you want to perform "],
["filter-retaining-rows.html", "4.2 filter(): Retaining Rows", " 4.2 filter(): Retaining Rows This function allows you to subset the data frame based on a logical test. Simply put, it allows you to choose which rows to keep. 4.2.1 filter() Structure filter(data, logical_test, …) Remember, all dplyr functions take the same general form (See section 4.1). The first argument specifies the data frame that we are manipulating. The second argument specifies the transformation we want to preform. In this case transformation argument uses a logical test to define the observations we would like to keep. Logical tests can explicitly use logical operators (i.e., == or %in%). Functions that return logical values can also be used (i.e., is.na()). Multiple logical tests can be provided as indicated by the elipse. If they are separated by a comma or ampersand, both tests must be TRUE for the observation to be retained. If they are separated by a pipe (i.e., |), either argument can be satisfied for the observation to be retained 4.2.2 Using filter() Remember the survey data? Some observations were created when you were pilot testing the survey. These are not informative because they do not come from your sample and should be removed. Luckily, the survey platform records whether a response is from a participant or a tester in the Status column (0 = participant, 8 = tester). Using filter() we can easily retain the real observations while exculding rows associated with the pilot test. Table 4.1: Full Survey Data ResponseId Status last_name Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_3oR2O5GVj417Rb8 8 NA NA 1 2 1 1 1 R_24kfInksYNZC2Bb 0 NA 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 0 NA 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 0 NA 5 1 1 3 1 1 R_3n9rQagKRteaa0F 0 NA 3 1 2 4 5 5 R_beYF2qSztK7r6jn 0 NA 5 1 4 5 4 3 Example 4.1 Using filter to retain non-pilot observations (Status = 1). filter(ex_data, Status == 0) Table 4.2: Filtered Survey Data ResponseId Status last_name Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 0 NA 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 0 NA 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 0 NA 5 1 1 3 1 1 R_3n9rQagKRteaa0F 0 NA 3 1 2 4 5 5 R_beYF2qSztK7r6jn 0 NA 5 1 4 5 4 3 Example 4.2 A less practical example that retains observations that responded to Q1.1 OR Q1.3 with 5 filter(ex_data, Q1.1 == 5 | Q1.3 == 5 ) Table 4.3: Filtered Survey Data ResponseId Status last_name Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_2Sq8eFhNWEfZOJd 0 NA 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 0 NA 5 1 1 3 1 1 R_beYF2qSztK7r6jn 0 NA 5 1 4 5 4 3 "],
["select-choosing-columns.html", "4.3 select(): Choosing Columns", " 4.3 select(): Choosing Columns Often when cleaning data, we only want to work a subset of columns. select() is used to choose specific columns. 4.3.1 select() Structure select(data, cols_to_keep, …) Again, select() takes the general dplyr form (See section 4.1). The first argument specifies the data frame that we are manipulating. The second argument specifies the transformation we want to preform. In this case, the transformation argument specifies a column or columns we would like to keep, separated by commas. If you want to keep a range of columns you can specify the first column and last column of the range with a colon. Sometimes, it is more effecient to drop then select columns. To remove columns, simply include a minus sign infront of the column. The columns will be ordered how you type them. 4.3.2 Useful Helper Functions for select() starts_with() used in tandem select() allows you to keep variables that share a stem. ends_with() used in tandem with select() allows you to keep variables that share a suffix. contains() used in tandem with select() allows you to keep variables that share some common string anywhere in their structure. These can be used along with regular expressions to automate large portions of data cleaning. Helper Functions can speed up the data cleaning process while keeping your code easy to interpret. 4.3.3 Using select() Again, this function helps us solve two issues in the survey data example. The survey platform created a column of data for the participant’s last name that is completely empty. Furthermore, the Status column is no longer informative. We can remove this column entirely using the select function. All of the following examples complete the same task using different methods although some are more efficient than others! Table 4.4: Survey Data with No Test Cases ResponseId Status last_name Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 0 NA 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 0 NA 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 0 NA 5 1 1 3 1 1 R_3n9rQagKRteaa0F 0 NA 3 1 2 4 5 5 R_beYF2qSztK7r6jn 0 NA 5 1 4 5 4 3 Example 4.3 Using select() by specifying columns to retain. select(ex_data, ResponseId, Q1.1, Q1.2, Q1.3, Q2.1, Q2.2, Q2.3) Table 4.5: Survey Data: Retained Columns ResponseId Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.4 Using select() by specifying columns to omit. select(ex_data, -Status, -last_name) Table 4.6: Survey Data: Dropped Columns ResponseId Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.5 Using select() by specifying range of columns. select(ex_data, ResponseId, Q1.1:Q2.3) Table 4.7: Survey Data: Column Range ResponseId Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.6 Using select() with helper functions. select(ex_data, contains(&quot;id&quot;, ignore.case = TRUE), starts_with(&quot;Q&quot;)) Table 4.8: Survey Data: Helper Functions ResponseId Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 "],
["rename-renaming-variables.html", "4.4 rename(): Renaming Variables", " 4.4 rename(): Renaming Variables This function is very self explanatory - it renames columns (variables) 4.4.1 rename() Structure rename(data, old_name = new_name, …) Following the general dplyr form (See section 4.1), the first argument specifies the data you are manipulating. In this case the transformation arguments take the form of an equation where the new column name is on the left of the equals sign and the old column name is on the right. Multiple variables can be renamed within one rename call, as indicated by the elipse. 4.4.2 Using rename() Given that Q1.x and Q2.x are not meaninful stems, we should rename the items so that they are interpretable. It turns out items in labeled Q1 measured consientousness and items in Q2 measured job performance. Table 4.9: Survey Data: Selected Columns ResponseId Q1.1 Q1.2 Q1.3 Q2.1 Q2.2 Q2.3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.7 Using rename() to provide substantive column names. rename(ex_data, cons1 = Q1.1, cons2 = Q1.2, cons3 = Q1.3, perf1 = Q2.1, perf2 = Q2.2, perf3 = Q2.3) Table 4.10: Survey Data: Renaming Columns ResponseId cons1 cons2 cons3 perf1 perf2 perf3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.8 select() can be used to rename columns as well! select(ex_data, ResponseId, cons1 = Q1.1, cons2 = Q1.2, cons3 = Q1.3, perf1 = Q2.1, perf2 = Q2.2, perf3 = Q2.3) Table 4.11: Survey Data: Using select() to rename columns ResponseId cons1 cons2 cons3 perf1 perf2 perf3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.9 rename() may be one area where dplyr is lacking in efficiency. Here is the base R code to do the same task! colnames(ex_data)&lt;-c(&quot;ResponseId&quot;, paste0(&quot;cons&quot;, 1:3), paste0(&quot;perf&quot;, 1:3)) ex_data Table 4.12: Survey Data: Using Base R to Rename Columns ResponseId cons1 cons2 cons3 perf1 perf2 perf3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 "],
["mutate-creating-new-variables.html", "4.5 mutate(): Creating New Variables", " 4.5 mutate(): Creating New Variables mutate() creates new variables that are defined by some function or operation. 4.5.1 mutate() Structure mutate(data, new_var = function, …) Again, following the general dplyr form (See section 4.1), the first argument specifies the data you are manipulating. The next argument specifies the transformation, which in mutate() defines a new variable. To do this, you specificy a formula that specifies the name of a new variable on the left of the equals sign and a function that creates the new variable on the right. In this notation, function refers to any function or operator that creates a vector of output that is as long as the data frame or has a single value. Multiple new variables can be created within one mutate() call, but should be spearated by commas. 4.5.2 Helper Functions rowwise(): Applies functions across columns within rows. ungroup(): Undoes grouping functions such as rowwise() and group_by() (group_by will be discussed in Section 4.7) 4.5.3 Using mutate() Given that their are two subscales (i.e., conscientousness and performance) within our survey data, we can create scale scores for these sets of items. Typically this is done by averaging the item level data. mutate() provides an easy way to do this! Table 4.13: Survey Data: Renamed Columns ResponseId cons1 cons2 cons3 perf1 perf2 perf3 R_24kfInksYNZC2Bb 2 1 1 4 5 3 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 R_3n9rQagKRteaa0F 3 1 2 4 5 5 R_beYF2qSztK7r6jn 5 1 4 5 4 3 Example 4.10 Using mutate() and arithmetic operators to create scale scores with missing data. mutate(ex_data, cons = (cons1+cons2+cons3)/3, perf = (perf1+perf2+perf3)/3) Table 4.14: Survey Data: Renamed Columns ResponseId cons1 cons2 cons3 perf1 perf2 perf3 cons perf R_24kfInksYNZC2Bb 2 1 1 4 5 3 1.33 4.00 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 3.00 1.00 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 2.33 1.67 R_3n9rQagKRteaa0F 3 1 2 4 5 5 2.00 4.67 R_beYF2qSztK7r6jn 5 1 4 5 4 3 3.33 4.00 Example 4.11 Using mutate() and rowwise() to create scale scores while handling missing data (use with caution). ungroup(mutate(rowwise(ex_data), cons = mean(c(cons1,cons2,cons3), na.rm = TRUE), perf = mean(c(perf1,perf2,perf3), na.rm = TRUE))) Table 4.15: Survey Data: Renamed Columns ResponseId cons1 cons2 cons3 perf1 perf2 perf3 cons perf R_24kfInksYNZC2Bb 2 1 1 4 5 3 1.33 4.00 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 3.00 1.00 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 2.33 1.67 R_3n9rQagKRteaa0F 3 1 2 4 5 5 2.00 4.67 R_beYF2qSztK7r6jn 5 1 4 5 4 3 3.33 4.00 "],
["the-pipe-operator.html", "4.6 The Pipe Operator (%&gt;%)", " 4.6 The Pipe Operator (%&gt;%) Notice that while cleaning the survey data we have been typing the data argument multiple times. Furthermore, using rowwise() and ungroup() with mutate() makes our code difficult to read! Wouldn’t it be nice if there was some short hand way to link functions together? Lucky for us there is, and it is call the pipe operator which lin. The pipe operator carrys forward the output of the previous function and uses it in the function that follows. This allows you to string together multiple functions without retyping the data argument. 4.6.1 Structure of the Pipe Operator function1(data, transformation, …)%&gt;% function2(transformation) The pipe operator carriers forward the output of the previous call and uses it in the subsequent function Thus following any function or object call with %&gt;% will carry forward the output into the next function that is called 4.6.2 Using the pipe operator Lets use the pipe operator to make our code more readable Example 4.12 Using pipe operator (%&gt;%) to redo what we have done thus far. ex_data%&gt;% filter(Status == 0)%&gt;% select(-Status, -last_name)%&gt;% rename(cons1 = Q1.1, cons2 = Q1.2, cons3 = Q1.3, perf1 = Q2.1, perf2 = Q2.2, perf3 = Q2.3)%&gt;% rowwise()%&gt;% mutate(cons = mean(c(cons1,cons2,cons3), na.rm = TRUE), perf = mean(c(perf1,perf2,perf3), na.rm = TRUE))%&gt;% ungroup() ResponseId cons1 cons2 cons3 perf1 perf2 perf3 cons perf R_24kfInksYNZC2Bb 2 1 1 4 5 3 1.33 4.00 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 3.00 1.00 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 2.33 1.67 R_3n9rQagKRteaa0F 3 1 2 4 5 5 2.00 4.67 R_beYF2qSztK7r6jn 5 1 4 5 4 3 3.33 4.00 "],
["group.html", "4.7 group_by(): Grouping Data Frames", " 4.7 group_by(): Grouping Data Frames Sometimes, when working with data we want to perform some operation within a grouping variable. For example, imagine the employees responding to the survey we have been working with report to different managers. We may be interested in creating a new column of data that contains the work-groups’ average performance. group_by() can be used in tandem with mutate() to apply a function within columns clustering on groups 4.7.1 group_by Structure group_by(data, grouping_variable, …) group_by() takes the common dplyr structure - define the data and then define the transformation. The transforamation in this case simply defines the grouping variable. If multiple grouping variables are provided, the data is grouped by unique combinations of the grouping variables. Note that this function is similar to rowwise() in that no physical change happens to the data - it only affects how later functions act the object. Because of this, group_by() is rarely (dare I say never) used without being accompanied by other functions such as mutate() or summarise() (to be covered in Section 4.8) Also, just like rowwise(), in order return the dataset to its ungrouped form it is necessary to call the ungroup() function after finishing grouped manipulations. 4.7.2 Using group_by() The survey data has been merged with information regarding employees managers. Some potentially useful information can be derived now that we have a grouping variable. We can include the employee’s team’s average performance, average conscientousness, and team size in the data. While I only illustrate how to use group_by() with the pipe operator, if for some reason you wanted to use a single group_by() call instead of a chain, it can be done. ResponseId Manager cons perf R_24kfInksYNZC2Bb Nick 1.333333 4.000000 R_2Sq8eFhNWEfZOJd Julia 3.000000 1.000000 R_BWjnVPEG2iVgRKp Nick 2.333333 1.666667 R_3n9rQagKRteaa0F Nick 2.000000 4.666667 R_beYF2qSztK7r6jn Julia 3.333333 4.000000 Example 4.13 Using group_by() to create team level variables and n() to create group size variables ex_data%&gt;% group_by(Manager)%&gt;% mutate(ave_cons = mean(cons, na.rm = TRUE), team_perf = mean(cons, na.rm = TRUE), team_size = n()) ResponseId Manager cons perf team_cons team_perf team_size R_24kfInksYNZC2Bb Nick 1.333333 4.000000 1.888889 1.888889 3 R_2Sq8eFhNWEfZOJd Julia 3.000000 1.000000 3.166667 3.166667 2 R_BWjnVPEG2iVgRKp Nick 2.333333 1.666667 1.888889 1.888889 3 R_3n9rQagKRteaa0F Nick 2.000000 4.666667 1.888889 1.888889 3 R_beYF2qSztK7r6jn Julia 3.333333 4.000000 3.166667 3.166667 2 "],
["sum.html", "4.8 summarise(): Creating Data Summaries", " 4.8 summarise(): Creating Data Summaries While creating grouped variables is sometimes necessary for analyses, often we simply want to describe properties of our data. summarise() is especially useful for this because it applies a function across rows of data to create a single value. If the data is grouped, there is a value returned for each group. 4.8.1 summarise() Structure summarise(data, summary_var = function, …) Following the consistent dplyr structure, summarise() requires that you first specify the data and then a transformation. The transformation in summarise takes a similar form as mutate() the left hand side of the equation defines the name of a new summary variable and the right hand side defines a function or operation. The function should return a single value (i.e., mean() or sd()). 4.8.2 Using summarise() Let’s create a sumary table for the overall sample as well as each team Example 4.14 Using summarise() to create a summary table for the entire survey data frame ex_data%&gt;% summarise(mean_cons = mean(cons, na.rm = TRUE), mean_perf = mean(perf, na.rm = TRUE), sd_cons = sd(cons, na.rm = TRUE), sd_perf = sd(perf, na.rm = TRUE)) Table 4.16: Summary Statistics for the Entire Sample mean_cons mean_perf sd_cons sd_perf 2.4 3.066667 0.7958224 1.622755 Example 4.15 Using group_by() and summarise() to create a summary table for different work groups ex_data%&gt;% group_by(Manager)%&gt;% summarise(team_cons = mean(cons, na.rm = TRUE), team_perf = mean(perf, na.rm = TRUE), sd_cons = sd(cons, na.rm = TRUE), sd_perf = sd(perf, na.rm = TRUE)) Table 4.17: Summary Statistics by Team Manager team_cons team_perf sd_cons sd_perf Julia 3.166667 2.500000 0.2357023 2.121320 Nick 1.888889 3.444444 0.5091751 1.575272 "],
["arrange-ordering-rows.html", "4.9 arrange(): Ordering Rows", " 4.9 arrange(): Ordering Rows arrange() can be used to sort rows in a data frame By default, arrange() orders a data frame from values in a column that go from smallest to largest You can use desc() with arrange to sort from largest to smallest 4.9.1 arrange() Structure arrange(data, sort_var, …) arrange() takes the same structure as all other core dplyr functions. First, specify the data you are manipulating Second, specify the transformation - the column or columns you are sorting by If multiple columns are provided, arrange will sort by the first column and use subsequent columns as tie breakers 4.9.2 Using arrange() Example 4.16 Adding arrange() to our summary table ex_data%&gt;% group_by(Manager)%&gt;% summarise(team_cons = mean(cons, na.rm = TRUE), team_perf = mean(perf, na.rm = TRUE), sd_cons = sd(cons, na.rm = TRUE), sd_perf = sd(perf, na.rm = TRUE))%&gt;% arrange(team_cons) Manager team_cons team_perf sd_cons sd_perf Nick 1.888889 3.444444 0.5091751 1.575272 Julia 3.166667 2.500000 0.2357023 2.121320 Example 4.17 Sorting the summary table in descending order with desc() and arrange() ex_data%&gt;% group_by(Manager)%&gt;% summarise(team_cons = mean(cons, na.rm = TRUE), team_perf = mean(perf, na.rm = TRUE), sd_cons = sd(cons, na.rm = TRUE), sd_perf = sd(perf, na.rm = TRUE))%&gt;% arrange(desc(team_cons)) Manager team_cons team_perf sd_cons sd_perf Julia 3.166667 2.500000 0.2357023 2.121320 Nick 1.888889 3.444444 0.5091751 1.575272 "],
["activity-1.html", "Chapter 5 Activity 1", " Chapter 5 Activity 1 Now it’s your turn! You can find a data set titled “survey data.csv” in the supplemental material. Your goal is to clean the data and then summarise the data in a meaningful way. Instructions Keep observations that completed the survey AND were not from a test run. Remove columns that only contain missing data or a single value for every observation. Rename variables that start with Q to something meaningful. Create scale scores for the two different subscales in the data. Generate summaries for the two new subscales for the entire data set and a grouping variable Advanced Activity Did respondents complete the survey multiple times? On average how many times did each participant respond? Create scale scores that use mean(…, na.rm = TRUE) for participants that responded to 2 or more items, otherwise assign the respondent missing values. "],
["join-functions.html", "Chapter 6 Join Functions", " Chapter 6 Join Functions Let’s look at the original survey data set after it was cleaned up. ResponseId cons1 cons2 cons3 perf1 perf2 perf3 cons perf R_24kfInksYNZC2Bb 2 1 1 4 5 3 1.33 4.00 R_2Sq8eFhNWEfZOJd 5 1 3 1 1 1 3.00 1.00 R_BWjnVPEG2iVgRKp 5 1 1 3 1 1 2.33 1.67 R_3n9rQagKRteaa0F 3 1 2 4 5 5 2.00 4.67 R_beYF2qSztK7r6jn 5 1 4 5 4 3 3.33 4.00 Note that manager information was not originally stored in this data - two data sets had to be merged with this data frame. ResponseId Manager R_3oR2O5GVj417Rb8 David R_24kfInksYNZC2Bb Nick R_2Sq8eFhNWEfZOJd Julia R_BWjnVPEG2iVgRKp Nick R_3n9rQagKRteaa0F Nick R_beYF2qSztK7r6jn Julia R_3oR4O5GVj417Rb8 David R_44kfInksYNZC2Bb David R_4Sq8eFhNWEfZOJd Julia R_BWjnVPEG4iVgRKp Nick R_3n9rQagKRteaa0F Nick R_beYF4qSztK7r6jn Julia Merging data sets can be rather complicated, as you will soon see. Luckily the creators of dplyr wrote a set of functions that make merging multiple data tables easy "],
["overview-of-dplyr-functions-for-joining-and-binding.html", "6.1 Overview of dplyr Functions for Joining and Binding", " 6.1 Overview of dplyr Functions for Joining and Binding 6.1.1 Binding Functions bind_rows(): Stacks many data frames vertically. bind_cols(): Joins many date frames horizontally. 6.1.2 Mutating Joins left_join(): Joins based on an ID variable. Retains all rows in left data frame and only matching rows in the right. right_join(): Joins based on an ID variable. Retains all rows in the right data frame and only matching rows in the left. inner_join(): Joins based on an ID variable. Retains only matching rows for both data frames. full_join(): Joins based on an ID variable (Considers order). Retains only matching rows for 6.1.3 Filtering Joins semi_join(): Retains rows in the left hand data frame that match an ID variable in the right hand data frame. anit_join(): Reains rows in the left hand data frame that do NOT match and ID variable in the right hand data frame. "],
["bind-cols-binding-data-frames-horizontally.html", "6.2 bind_cols(): Binding Data Frames Horizontally", " 6.2 bind_cols(): Binding Data Frames Horizontally bind_cols is used when you have a set of data frames that Have equal number of rows Are ordered identically, with no missing information If these two requirements are not met, the data will joined combining information about different participants If your data does not meet either of these requirements, use a join function discussed below. 6.2.1 bind_cols() Structure bind_cols(…) bind_cols() takes two or more data frames (or a list of data frames) that have an equal number of identically ordered rows. 6.2.2 Using bind_cols() Note that, while for the survey data we want to combine two data frames horizontally, the data frames do not have the same number of rows. Furthemore, based on the responseId variable, we know that participants are not in the same order. Thus we are probably better off using a different function to join these two data sets. In contrast, note that in the two tabels below, each data frame has the same number of observations and the ID variables align perfectly. Table 6.1: Two Tables With Corresponding Rows and Equal Dimensions ResponseId cons R_24kfInksYNZC2Bb 1.33 R_2Sq8eFhNWEfZOJd 3.00 R_BWjnVPEG2iVgRKp 2.33 R_3n9rQagKRteaa0F 2.00 R_beYF2qSztK7r6jn 3.33 ResponseId perf R_24kfInksYNZC2Bb 4.00 R_2Sq8eFhNWEfZOJd 1.00 R_BWjnVPEG2iVgRKp 1.67 R_3n9rQagKRteaa0F 4.67 R_beYF2qSztK7r6jn 4.00 Example 6.1 Binding data frames together horizontally. bind_cols(cons_dat, perf_dat) Table 6.2: Output of bind_cols() ResponseId cons ResponseId1 perf R_24kfInksYNZC2Bb 1.33 R_24kfInksYNZC2Bb 4.00 R_2Sq8eFhNWEfZOJd 3.00 R_2Sq8eFhNWEfZOJd 1.00 R_BWjnVPEG2iVgRKp 2.33 R_BWjnVPEG2iVgRKp 1.67 R_3n9rQagKRteaa0F 2.00 R_3n9rQagKRteaa0F 4.67 R_beYF2qSztK7r6jn 3.33 R_beYF2qSztK7r6jn 4.00 Note that, since there is a dupicate column (ResponseId) in the new joined dataset, col_bind() automatically added a 1 to the end of the column name While this example was adequate for illustration purposes, in practice, join functions are more flexible and appropriate when data sets have shared identifier. "],
["bind-rows-binding-data-frames-vertically.html", "6.3 bind_rows(): Binding Data Frames Vertically", " 6.3 bind_rows(): Binding Data Frames Vertically bind_rows() is used when you want to bind data frames vertically This is sometimes referred to as stacking data frames Unlike bind_cols(), bind_rows() attempts to match columns based on their name If a data frame is missing a column, observations will have missing data for that variable 6.3.1 bind_rows() Structure bind_rows(…) bind_rows() takes two or more data frames (or a list of data frames) 6.3.2 Using bind_rows() Table 6.3: Two data frames with a different number of columns ordered differently. ResponseId cons perf R_24kfInksYNZC2Bb 1.33 4.00 R_2Sq8eFhNWEfZOJd 3.00 1.00 R_BWjnVPEG2iVgRKp 2.33 1.67 Manager ResponseId perf cons Nick R_3n9rQagKRteaa0F 4.67 2.00 Nick R_3n9rQagKRteaa0F 4.67 2.00 Julia R_beYF2qSztK7r6jn 4.00 3.33 Example 6.2 Binding data frames together vertically (AKA, stacking). bind_rows(cons_dat, perf_dat) Table 6.4: Output of bind_cols() ResponseId cons perf Manager R_24kfInksYNZC2Bb 1.33 4.00 NA R_2Sq8eFhNWEfZOJd 3.00 1.00 NA R_BWjnVPEG2iVgRKp 2.33 1.67 NA R_3n9rQagKRteaa0F 2.00 4.67 Nick R_3n9rQagKRteaa0F 2.00 4.67 Nick R_beYF2qSztK7r6jn 3.33 4.00 Julia Note that columns that are named the same are appropriately matched. Furthermore, observations from a data frames that is missing a column are assigned NA for that variable. "],
["references.html", "References", " References "]
]
